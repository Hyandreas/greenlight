import { CompatibilityResult } from '../types';

export function generateMarkdownReport(results: CompatibilityResult[]): string {
  if (results.length === 0) {
    return `# âœ… Baseline Compatibility Report

No compatibility issues found! All features are baseline-compatible.

*Report generated by [Baseline Buddy](https://github.com/baseline-buddy/baseline-buddy)*`;
  }

  const errorCount = results.filter(r => r.severity === 'error').length;
  const warningCount = results.filter(r => r.severity === 'warning').length;
  const infoCount = results.filter(r => r.severity === 'info').length;
  
  let report = `# ğŸš¨ Baseline Compatibility Report

Found **${results.length}** compatibility issues:
- ğŸ”´ **${errorCount}** errors
- ğŸŸ¡ **${warningCount}** warnings  
- â„¹ï¸ **${infoCount}** info

## Issues by File

`;

  // Group results by file
  const resultsByFile = results.reduce((acc, result) => {
    if (!acc[result.file]) {
      acc[result.file] = [];
    }
    acc[result.file].push(result);
    return acc;
  }, {} as Record<string, CompatibilityResult[]>);

  for (const [file, fileResults] of Object.entries(resultsByFile)) {
    report += `### \`${file}\`\n\n`;
    
    for (const result of fileResults) {
      const icon = result.severity === 'error' ? 'ğŸ”´' : result.severity === 'warning' ? 'ğŸŸ¡' : 'â„¹ï¸';
      const location = result.line ? `:${result.line}${result.column ? `:${result.column}` : ''}` : '';
      
      report += `${icon} **${result.feature}** ${location}\n`;
      report += `   ${result.message}\n`;
      
      if (result.baseline && result.baseline !== 'unknown') {
        report += `   *Baseline status: ${result.baseline}*\n`;
      }
      
      if (result.fixes && result.fixes.length > 0) {
        const docFix = result.fixes.find(f => f.type === 'documentation');
        if (docFix) {
          report += `   ğŸ“– [Learn more](${docFix.url})\n`;
        }
      }
      
      report += '\n';
    }
  }

  report += `\n*Report generated by [Baseline Buddy](https://github.com/baseline-buddy/baseline-buddy)*`;
  
  return report;
}

export function generateSarifReport(results: CompatibilityResult[]): string {
  const sarif = {
    version: '2.1.0',
    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',
    runs: [{
      tool: {
        driver: {
          name: 'Baseline Buddy',
          version: '1.0.0',
          informationUri: 'https://github.com/baseline-buddy/baseline-buddy',
          rules: generateSarifRules(results)
        }
      },
      results: results.map(result => ({
        ruleId: result.feature,
        level: result.severity === 'error' ? 'error' : result.severity === 'warning' ? 'warning' : 'note',
        message: {
          text: result.message
        },
        locations: [{
          physicalLocation: {
            artifactLocation: {
              uri: result.file
            },
            region: {
              startLine: result.line || 1,
              startColumn: result.column || 1
            }
          }
        }],
        properties: {
          baseline: result.baseline,
          browserSupport: result.browserSupport
        }
      }))
    }]
  };
  
  return JSON.stringify(sarif, null, 2);
}

function generateSarifRules(results: CompatibilityResult[]) {
  const uniqueFeatures = [...new Set(results.map(r => r.feature))];
  
  return uniqueFeatures.map(feature => {
    const exampleResult = results.find(r => r.feature === feature);
    const docLink = exampleResult?.fixes?.find(f => f.type === 'documentation')?.url;
    
    return {
      id: feature,
      name: feature,
      shortDescription: {
        text: `${feature} compatibility issue`
      },
      fullDescription: {
        text: exampleResult?.message || `${feature} may not be compatible with all baseline browsers`
      },
      helpUri: docLink || `https://developer.mozilla.org/en-US/search?q=${encodeURIComponent(feature)}`,
      properties: {
        baseline: exampleResult?.baseline || 'unknown',
        category: 'baseline-compatibility'
      }
    };
  });
}

export function generateHumanReadableOutput(results: CompatibilityResult[]): string {
  if (results.length === 0) {
    return 'âœ… No compatibility issues found!';
  }

  const errorCount = results.filter(r => r.severity === 'error').length;
  const warningCount = results.filter(r => r.severity === 'warning').length;
  const infoCount = results.filter(r => r.severity === 'info').length;
  
  let output = `ğŸš¨ Found ${results.length} compatibility issues:\n`;
  output += `   ğŸ”´ ${errorCount} errors, ğŸŸ¡ ${warningCount} warnings, â„¹ï¸ ${infoCount} info\n\n`;

  // Group by file
  const resultsByFile = results.reduce((acc, result) => {
    if (!acc[result.file]) {
      acc[result.file] = [];
    }
    acc[result.file].push(result);
    return acc;
  }, {} as Record<string, CompatibilityResult[]>);

  for (const [file, fileResults] of Object.entries(resultsByFile)) {
    output += `ğŸ“„ ${file}\n`;
    
    for (const result of fileResults) {
      const icon = result.severity === 'error' ? 'ğŸ”´' : result.severity === 'warning' ? 'ğŸŸ¡' : 'â„¹ï¸';
      const location = result.line ? `:${result.line}${result.column ? `:${result.column}` : ''}` : '';
      
      output += `  ${icon} ${result.feature}${location}: ${result.message}\n`;
      
      if (result.baseline && result.baseline !== 'unknown') {
        output += `     Baseline: ${result.baseline}\n`;
      }
    }
    output += '\n';
  }
  
  return output;
}